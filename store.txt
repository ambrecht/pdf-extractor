navigationSlice.js:

import { createSlice } from '@reduxjs/toolkit';

const navigationSlice = createSlice({
  name: 'navigation',
  initialState: {
    controlPanelVisible: false,
    uploadFormVisible: true,
  },
  reducers: {
    toggleControlPanel: (state) => {
      state.controlPanelVisible = !state.controlPanelVisible;
    },
    toggleUploadForm: (state) => {
      state.uploadFormVisible = !state.uploadFormVisible;
    },
  },
});

// ACTIONS
export const { toggleControlPanel, toggleUploadForm } = navigationSlice.actions;

// SELECTORS
export const selectControlPanelVisible = (state) =>
  state.navigation.controlPanelVisible;
export const selectUploadFormVisible = (state) =>
  state.navigation.uploadFormVisible;

// REDUCER
export default navigationSlice.reducer;


store.js:

// Verzeichnispfad von store.js ist E:\pdf-extractor\store\store.js:

import { configureStore } from '@reduxjs/toolkit';
import teleprompterReducer from './teleprompterSlice';
import themeReducer from './themeSlice';
import uploadReducer from './uploadSlice';
import navigationReducer from './navigationSlice';

const store = configureStore({
  reducer: {
    teleprompter: teleprompterReducer,
    theme: themeReducer,
    upload: uploadReducer,
    navigation: navigationReducer, // Neuer Slice hinzugefÃ¼gt
  },
});

export default store;


teleprompterSlice.js:

import { createSlice } from '@reduxjs/toolkit';
import { mergeDeepRight as merge } from 'ramda';
import { selectResponse } from './uploadSlice';
import countWords from '../utils/wordCount';
import estimateReadingTime from '../utils/readingTime';

const teleprompterSlice = createSlice({
  name: 'teleprompter',
  initialState: {
    wpm: 140,
    paragraphs: [],
    index: 0,
    time: 0,
    intervalIsRunning: false,
    isLinear: false,
    wordCount: 0,
    progress: 0,
  },
  reducers: {
    setWpm: (state, action) => merge(state, { wpm: action.payload }),
    setParagraphs: (state, action) =>
      merge(state, { paragraphs: action.payload }),
    setIndex: (state, action) => merge(state, { index: action.payload }),
    setTime: (state, action) => merge(state, { time: action.payload }),
    toggleIntervalRunning: (state) =>
      merge(state, { intervalIsRunning: !state.intervalIsRunning }),
    toggleLinearMode: (state) => merge(state, { isLinear: !state.isLinear }),
    setWordCount: (state, action) =>
      merge(state, { wordCount: action.payload }),
    setProgress: (state, action) => merge(state, { progress: action.payload }),
    handleNewParagraph: (state, action) => {
      const response = selectResponse(state);
      if (response && response.length > 0) {
        const randomIndex = Math.floor(Math.random() * response.length);
        return merge(state, {
          index: randomIndex,
        });
      }
      return state;
    },

    updateParagraphs: (state, action) => {
      const response = uploadSelectors.selectResponse(state);
      if (response && response.length >= 3) {
        const selectedParagraphs = [
          response[action.payload - 1]?.paragraph || '',
          response[action.payload]?.paragraph || '',
          response[action.payload + 1]?.paragraph || '',
        ];
        return merge(state, {
          paragraphs: selectedParagraphs,
          index: action.payload,
          time: estimateReadingTime(selectedParagraphs[1], state.wpm),
          wordCount: countWords(selectedParagraphs[1]),
          progress: 0,
        });
      }
      return state;
    },
  },
});

export const {
  handleNewParagraph,
  setWpm,
  setParagraphs,
  setIndex,
  setTime,
  toggleIntervalRunning,
  toggleLinearMode,
  setWordCount,
  setProgress,
  updateParagraphs, // Exportieren Sie die neue Aktion
} = teleprompterSlice.actions;

export default teleprompterSlice.reducer;


themeSlice.js:

import { createSlice } from '@reduxjs/toolkit';
import { assoc } from 'ramda';

const themeSlice = createSlice({
  name: 'theme',
  initialState: {
    fontSize: 16,
    fontColor: 'black',
    theme: 'light',
    textAlignment: 'left',
    backgroundColor: 'white',
  },
  reducers: {
    setFontSize: (state, action) => assoc('fontSize', action.payload, state),
    setFontColor: (state, action) => assoc('fontColor', action.payload, state),
    setTheme: (state, action) => assoc('theme', action.payload, state),
    setTextAlignment: (state, action) =>
      assoc('textAlignment', action.payload, state),
    setBackgroundColor: (state, action) =>
      assoc('backgroundColor', action.payload, state),
  },
});

export const {
  setFontSize,
  setFontColor,
  setTheme,
  setTextAlignment,
  setBackgroundColor,
} = themeSlice.actions;

export default themeSlice.reducer;


uploadSlice.js:

import {
  createSlice,
  createSelector,
  createAsyncThunk,
} from '@reduxjs/toolkit';
import axios from 'axios';

const isClient = typeof window !== 'undefined';
const initialResponse = isClient
  ? JSON.parse(localStorage.getItem('uploadedData')) || []
  : [];

export const uploadFile = createAsyncThunk(
  'upload/file',
  async (file, { rejectWithValue }) => {
    try {
      const formData = new FormData();
      formData.append('file', file);

      const res = await axios.post('/api/test', formData, {
        headers: {
          'Content-Type': 'multipart/form-data',
        },
      });
      return res.data;
    } catch (err) {
      return rejectWithValue(err.message);
    }
  },
);

const uploadSlice = createSlice({
  name: 'upload',
  initialState: {
    file: null,
    loading: false,
    error: null,
    response: [],
  },
  reducers: {
    setFile: (state, action) => {
      state.file = action.payload;
    },
  },
  extraReducers: (builder) => {
    builder
      .addCase(uploadFile.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(uploadFile.fulfilled, (state, action) => {
        state.loading = false;
        state.response = action.payload;

        // Speichern Sie die Antwort im localStorage
        if (isClient) {
          localStorage.setItem('uploadedData', JSON.stringify(action.payload));
        }
      })
      .addCase(uploadFile.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload;
      });
  },
});

export const selectFile = (state) => state.upload.file;
export const selectResponse = (state) => state.upload.response;

export const { setFile } = uploadSlice.actions;
export default uploadSlice.reducer;


