E:\pdf-extractor\store\debug.log:

[0819/075525.845:ERROR:registration_protocol_win.cc(107)] CreateFile: Das System kann die angegebene Datei nicht finden. (0x2)
[0819/075741.435:ERROR:registration_protocol_win.cc(107)] CreateFile: Das System kann die angegebene Datei nicht finden. (0x2)


E:\pdf-extractor\store\documentsSlice.js:

import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import { supabase } from '../supabase/index';

export const fetchBooks = createAsyncThunk('books/fetch', async () => {
  const { data, error } = await supabase.from('book').select('*');
  console.log(data);
  if (error) throw error;
  return data;
});

const booksSlice = createSlice({
  name: 'books',
  initialState: {
    data: [],
    loading: false,
    error: null,
  },
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(fetchBooks.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchBooks.fulfilled, (state, action) => {
        state.loading = false;
        state.data = action.payload;
      })
      .addCase(fetchBooks.rejected, (state, action) => {
        state.loading = false;
        state.error = action.error.message;
      });
  },
});

export default booksSlice.reducer;


E:\pdf-extractor\store\navigationSlice.js:

import { createSlice } from '@reduxjs/toolkit';

const navigationSlice = createSlice({
  name: 'navigation',
  initialState: {
    controlPanelVisible: false,
    uploadFormVisible: false,
    optionsPanelVisible: false,
    documentsPanelVisible: false, // Neue Option für das Optionspanel
  },
  reducers: {
    toggleControlPanel: (state) => {
      state.controlPanelVisible = !state.controlPanelVisible;
    },
    toggleUploadForm: (state) => {
      state.uploadFormVisible = !state.uploadFormVisible;
    },
    toggleOptionsPanel: (state) => {
      // Neue Reducer-Funktion
      state.optionsPanelVisible = !state.optionsPanelVisible;
    },

    toggleDocumentsPanel: (state) => {
      state.documentsPanelVisible = !state.documentsPanelVisible;
    },
  },
});

// ACTIONS
export const {
  toggleControlPanel,
  toggleUploadForm,
  toggleOptionsPanel,
  toggleDocumentsPanel,
} = navigationSlice.actions;

// SELECTORS
export const selectControlPanelVisible = (state) =>
  state.navigation.controlPanelVisible;
export const selectUploadFormVisible = (state) =>
  state.navigation.uploadFormVisible;
export const selectOptionsPanelVisible = (state) =>
  state.navigation.optionsPanelVisible;
// Neuer Selector
export const selectDocumentsPanelVisible = (state) =>
  state.navigation.documentsPanelVisible; //
// REDUCER
export default navigationSlice.reducer;


E:\pdf-extractor\store\store.js:

import { configureStore } from '@reduxjs/toolkit';
import teleprompterReducer from './teleprompterSlice';
import themeReducer from './themeSlice';
import uploadReducer from './uploadSlice';
import navigationReducer from './navigationSlice';
import documentsSlice, { fetchBooks } from './documentsSlice'; // Importieren Sie fetchBooks

const store = configureStore({
  reducer: {
    teleprompter: teleprompterReducer,
    theme: themeReducer,
    upload: uploadReducer,
    navigation: navigationReducer,
    documents: documentsSlice,
  },
});

// Rufen Sie die fetchBooks-Aktion direkt nach der Erstellung des Stores auf
store.dispatch(fetchBooks());

export default store;


E:\pdf-extractor\store\teleprompterSlice.js:

import { createSlice } from '@reduxjs/toolkit';
import { mergeDeepRight as merge } from 'ramda';
import { selectResponse } from './uploadSlice';
import countWords from '../utils/wordCount';
import estimateReadingTime from '../utils/readingTime';
const teleprompterSlice = createSlice({
  name: 'teleprompter',
  initialState: {
    wpm: 140,
    paragraphs: [],
    index: 5,
    time: 0,
    intervalIsRunning: false,
    isLinear: false,
    wordCount: 0,
    progress: 0,
    paragraphcount: 0,
    bookID: 0,
  },
  reducers: {
    setParagraphCount: (state, action) =>
      merge(state, { paragraphcount: action.payload }),
    setWpm: (state, action) => merge(state, { wpm: action.payload }),
    setParagraphs: (state, action) =>
      merge(state, { paragraphs: action.payload }),
    setIndex: (state, action) => merge(state, { index: action.payload }),
    setTime: (state, action) => merge(state, { time: action.payload }),
    toggleIntervalRunning: (state) =>
      merge(state, { intervalIsRunning: !state.intervalIsRunning }),
    toggleLinearMode: (state) => merge(state, { isLinear: !state.isLinear }),
    setWordCount: (state, action) =>
      merge(state, { wordCount: action.payload }),
    setProgress: (state, action) => merge(state, { progress: action.payload }),
    handleNewParagraph: (state, action) => {
      const response = selectResponse(state);
      if (response && response.length > 0) {
        const randomIndex = Math.floor(Math.random() * response.length);
        return merge(state, {
          index: randomIndex,
        });
      }
      return state;
    },
    updateParagraphs: (state, action) => {
      const response = uploadSelectors.selectResponse(state);
      if (response && response.length >= 3) {
        const selectedParagraphs = [
          response[action.payload - 1]?.paragraph || '',
          response[action.payload]?.paragraph || '',
          response[action.payload + 1]?.paragraph || '',
        ];
        return merge(state, {
          paragraphs: selectedParagraphs,
          index: action.payload,
          time: estimateReadingTime(selectedParagraphs[1], state.wpm),
          wordCount: countWords(selectedParagraphs[1]),
          progress: 0,
        });
      }
      return state;
    },
    setBookId: (state, action) => {
      state.bookID = action.payload;
    },
    selectBookId: (state) => state.bookID,
  },
});
export const {
  handleNewParagraph,
  setWpm,
  setParagraphs,
  setIndex,
  setTime,
  toggleIntervalRunning,
  toggleLinearMode,
  setWordCount,
  setProgress,
  updateParagraphs,
  setParagraphCount,
  setBookId, // Exportieren Sie die setBookId Aktion
  selectBookId, // Exportieren Sie die selectBookId Aktion
} = teleprompterSlice.actions;
export default teleprompterSlice.reducer;


E:\pdf-extractor\store\themeSlice.js:

import { createSlice } from '@reduxjs/toolkit';

const themeSlice = createSlice({
  name: 'theme',
  initialState: {
    fontSize: '16px',
    fontColor: '#FFFFFF',
    textAlignment: 'left',
    backgroundColor: '#000000', // Setzen Sie einen Standardwert oder lassen Sie ihn leer
    animation: 'off',
    np: 'none',
    progressBarColor: '#FFFFFF',
  },
  reducers: {
    setFontSize: (state, action) => {
      state.fontSize = action.payload;
    },
    setFontColor: (state, action) => {
      state.fontColor = action.payload;
      state.progressBarColor = action.payload;
    },
    setBackgroundColor: (state, action) => {
      state.backgroundColor = action.payload;
    },
    invertTheme: (state) => {
      const tempColor = state.fontColor;
      state.fontColor = state.backgroundColor;
      state.backgroundColor = tempColor;
    },
    setTextAlignment: (state, action) => {
      state.textAlignment = action.payload;
    },
    setAnimation: (state, action) => {
      state.animation = action.payload;
    },
    setProgressDisplay: (state, action) => {
      state.progressDisplay = action.payload;
    },
  },
});

export const {
  setFontSize,
  setFontColor,
  setBackgroundColor, // Stellen Sie sicher, dass Sie diese Aktion exportieren
  invertTheme,
  setTextAlignment,
  setAnimation,
  setProgressDisplay,
} = themeSlice.actions;

export default themeSlice.reducer;


E:\pdf-extractor\store\uploadSlice.js:

import {
  createSlice,
  createSelector,
  createAsyncThunk,
} from '@reduxjs/toolkit';
import axios from 'axios';

const isClient = typeof window !== 'undefined';
const initialResponse = isClient
  ? JSON.parse(localStorage.getItem('uploadedData')) || []
  : [];

export const uploadFile = createAsyncThunk(
  'upload/file',
  async (file, { getState, rejectWithValue }) => {
    try {
      const state = getState(); // Abrufen des aktuellen Zustands
      const { title, author } = state.upload; // Extrahieren von Titel und Autor aus dem Zustand
      console.log(title, author);
      const formData = new FormData();
      formData.append('file', file);
      formData.append('title', title); // Hinzufügen des Titels zum FormData
      formData.append('author', author); // Hinzufügen des Autors zum FormData

      const res = await axios.post('/api/xxx', formData, {
        headers: {
          'Content-Type': 'multipart/form-data',
        },
      });
      return res.data;
    } catch (err) {
      return rejectWithValue(err.message);
    }
  },
);

const uploadSlice = createSlice({
  name: 'upload',
  initialState: {
    author: '',
    title: '',
    file: null,
    loading: false,
    error: null,
    response: initialResponse,
  },
  reducers: {
    setFile: (state, action) => {
      state.file = action.payload;
    },
    setTitle: (state, action) => {
      // Aktion zum Setzen des Buchtitels
      state.title = action.payload;
    },
    setAuthor: (state, action) => {
      // Aktion zum Setzen des Autors
      state.author = action.payload;
    },
  },
  extraReducers: (builder) => {
    builder
      .addCase(uploadFile.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(uploadFile.fulfilled, (state, action) => {
        state.loading = false;
        state.response = action.payload;
        // Speichern Sie die Antwort im localStorage
        if (isClient) {
          localStorage.setItem('uploadedData', JSON.stringify(action.payload));
        }
      })
      .addCase(uploadFile.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload;
      });
  },
});

export const selectFile = (state) => state.upload.file;
export const selectResponse = (state) => state.upload.response;
export const { setFile, setTitle, setAuthor } = uploadSlice.actions; // Exportieren Sie die neuen Aktionen
export default uploadSlice.reducer;


