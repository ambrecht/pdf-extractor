Natürlich! Beginnen wir mit der Middleware, die die Nebeneffekte in unserem Redux-Store behandelt. Wir werden Redux Thunk verwenden, da es eine weit verbreitete Middleware ist, die es uns ermöglicht, asynchrone Aktionen in Redux zu schreiben.
Middleware

Wir werden eine Thunk-Action erstellen, die die Logik für das Intervall und den Fortschritt enthält, die zuvor in den useEffect-Hooks waren.

javascript

import estimateReadingTime from '../utils/readingTime';
import countWords from '../utils/wordCount';

export const updateParagraphsAndProgress = () => (dispatch, getState) => {
  const state = getState().teleprompter;
  const { index, wpm, data, intervalIsRunning, time } = state;

  if (index !== null) {
    const selectedParagraphs = [
      data[index - 1]?.paragraph || '',
      data[index]?.paragraph || '',
      data[index + 1]?.paragraph || '',
    ];
    const newTime = estimateReadingTime(selectedParagraphs[1], wpm);
    const wordCount = countWords(selectedParagraphs[1]);
    dispatch(updateParagraphsAndTime({ paragraphs: selectedParagraphs, time: newTime, wordCount, progress: 0 }));
  }

  if (intervalIsRunning) {
    let currentIndex = index;
    const id = setInterval(() => {
      if (state.isLinear) {
        currentIndex = (currentIndex + 1) % data.length;
      } else {
        currentIndex = Math.floor(Math.random() * data.length);
      }
      dispatch(setIndex({ index: currentIndex }));
      dispatch(setHistory({ history: [...state.history, currentIndex] }));
    }, time * 1000);

    const startTime = Date.now();
    const interval = setInterval(() => {
      const elapsedTime = (Date.now() - startTime) / 1000;
      const newProgress = (elapsedTime / (time - 1)) * 100;
      dispatch(updateProgress({ progress: newProgress > 100 ? 100 : newProgress }));
    }, 1000 / 60);

    return () => {
      clearInterval(id);
      clearInterval(interval);
    };
  }
};

Diese Thunk-Action kombiniert die Logik der useEffect-Hooks, die das Intervall und den Fortschritt behandeln, und verwendet die Redux-Dispatch-Funktion, um den Zustand entsprechend zu aktualisieren.

Bitte bestätigen Sie, dass dies korrekt ist, und ich werde mit dem nächsten Schritt fortfahren.
User
weiter
ChatGPT

Großartig! Jetzt werden wir den Reducer aktualisieren, um die Thunk-Action zu verwenden und die Logik, die wir in die Middleware verschoben haben, zu entfernen.
Reducer (Teil 1)

javascript

const initialState = {
  wpm: 160,
  paragraphs: [],
  index: null,
  time: 5,
  intervalIsRunning: false,
  isLinear: true,
  wordCount: 0,
  progress: 0,
  fontSize: 'text-5xl',
  fontColor: 'gray',
  history: [],
  backgroundColor: 'white',
  textAlignment: 'center',
  theme: 'light',
  scrollSpeed: 1,
  data: [] // Beispiel für Daten, die in der Hook verwendet wurden
};

const reducer = (state = initialState, { type, payload } = {}) => {
  switch (type) {
    case setWpm().type:
      return { ...state, wpm: payload.wpm };

    case setParagraphs().type:
      return { ...state, paragraphs: payload.paragraphs };

    case setIndex().type:
      return { ...state, index: payload.index };

    case setTime().type:
      return { ...state, time: payload.time };

    case toggleIntervalRunning().type:
      return { ...state, intervalIsRunning: !state.intervalIsRunning };

    case toggleLinearMode().type:
      return { ...state, isLinear: !state.isLinear };

    // ... Weitere Fälle
  }
};

In diesem ersten Teil des Reducers haben wir die Anfangszustände definiert und einige der grundlegenden Fälle behandelt. Wir haben auch ein data-Feld zum Anfangszustand hinzugefügt, das die Daten repräsentiert, die in der ursprünglichen Hook verwendet wurden.

Bitte bestätigen Sie, dass dies korrekt ist, und ich werde mit dem nächsten Teil des Reducers fortfahren.
User
weiter
ChatGPT

Perfekt! Hier ist der zweite Teil des Reducers, in dem wir weitere Fälle behandeln.
Reducer (Teil 2)

javascript

// ... Vorherige Fälle

case setWordCount().type:
  return { ...state, wordCount: payload.wordCount };

case setProgress().type:
  return { ...state, progress: payload.progress };

case setFontSize().type:
  return { ...state, fontSize: payload.fontSize };

case setFontColor().type:
  return { ...state, fontColor: payload.fontColor };

case setHistory().type:
  return { ...state, history: payload.history };

case handleNewParagraph().type:
  const randomIndex = Math.floor(Math.random() * state.data.length);
  return { ...state, index: randomIndex };

case handleNextClick().type:
  if (state.index < state.data.length - 1) {
    return { ...state, index: state.index + 1 };
  }
  return state;

case handlePrevClick().type:
  if (state.index > 0) {
    return { ...state, index: state.index - 1 };
  }
  return state;

// ... Weitere Fälle

In diesem Abschnitt haben wir die Fälle für die Aktionen behandelt, die den Zustand aktualisieren, einschließlich der Aktionen, die die Logik der Hook-Methoden handleNewParagraph, handleNextClick und handlePrevClick abbilden.

Bitte bestätigen Sie, dass dies korrekt ist, und ich werde mit dem nächsten Teil des Reducers fortfahren.
User
weiter
ChatGPT

Wunderbar! Hier ist der dritte Teil des Reducers, in dem wir die verbleibenden Fälle behandeln.
Reducer (Teil 3)

javascript

// ... Vorherige Fälle

case handleIntervalToggle().type:
  return { ...state, intervalIsRunning: !state.intervalIsRunning };

case updateParagraphsAndTime().type:
  return {
    ...state,
    paragraphs: payload.paragraphs,
    time: payload.time,
    wordCount: payload.wordCount,
    progress: payload.progress,
  };

case updateProgress().type:
  const newProgress = payload.progress > 100 ? 100 : payload.progress;
  return { ...state, progress: newProgress };

case setTheme().type:
  return { ...state, theme: payload.theme };

case setTextAlignment().type:
  return { ...state, textAlignment: payload.textAlignment };

case setBackgroundColor().type:
  return { ...state, backgroundColor: payload.backgroundColor };

case setScrollSpeed().type:
  return { ...state, scrollSpeed: payload.scrollSpeed };

default:
  return state;
}
};

export default reducer;

In diesem Abschnitt haben wir die verbleibenden Fälle behandelt, einschließlich der Aktionen, die die Logik der Hook-Methoden handleIntervalToggle abbilden, sowie der neuen Aktionen, die wir für die Aktualisierung von Absätzen, Zeit und Fortschritt hinzugefügt haben.

Damit ist der Reducer vollständig und enthält die gesamte Logik, die zuvor in der Hook enthalten war.

Bitte bestätigen Sie, dass dies korrekt ist, und ich werde mit den nächsten Schritten fortfahren, um den vollständigen Code in Ihre Anwendung zu integrieren.
User
weiter
ChatGPT

Fantastisch! Jetzt, da der Reducer fertig ist, müssen wir den Redux Store konfigurieren, um die Middleware zu verwenden, die wir geschrieben haben. Wir werden auch die Thunk-Middleware hinzufügen, um unsere Thunk-Action zu unterstützen.
Store-Konfiguration

javascript

import { createStore, applyMiddleware } from 'redux';
import thunk from 'redux-thunk';
import reducer from './reducer'; // Pfad zu Ihrem Reducer

const store = createStore(
  reducer,
  applyMiddleware(thunk)
);

export default store;

In diesem Code-Snippet haben wir den Redux Store mit dem Reducer und der Thunk-Middleware erstellt. Die Thunk-Middleware ermöglicht es uns, Thunk-Actions in unserem Store zu verwenden, die asynchrone Logik enthalten können.
Integration in die Anwendung

Um den Store in Ihrer Anwendung zu verwenden, müssen Sie den Provider von react-redux um Ihre Hauptkomponente herum einbetten:

javascript

import React from 'react';
import { Provider } from 'react-redux';
import store from './store'; // Pfad zu Ihrem Store
import App from './App'; // Ihre Hauptkomponente

const Root = () => (
  <Provider store={store}>
    <App />
  </Provider>
);

export default Root;

Jetzt ist der Redux Store vollständig in Ihre Anwendung integriert, und Sie können useDispatch und useSelector von react-redux verwenden, um auf den Zustand zuzugreifen und Aktionen in Ihren Komponenten zu versenden.

Bitte bestätigen Sie, dass dies korrekt ist, und ich werde Ihnen abschließende Anweisungen geben, um sicherzustellen, dass alles reibungslos funktioniert.